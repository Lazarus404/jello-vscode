// Jello Syntax Highlighting Test File
// This file demonstrates all language features for testing syntax highlighting

// ========================================
// 1. COMMENTS
// ========================================

// This is a single-line comment
// Multiple consecutive comments
// TODO: Comments should be highlighted differently

// ========================================
// 2. IMPORTS AND MODULES
// ========================================

using Crypto;
using System;

// ========================================
// 3. CONSTANTS AND PRIMITIVES
// ========================================

// Boolean literals
x := true;
y := false;

// Null
z := null;

// Integer literals
decimal := 42;
hex := 0xFF;
binary := 0b1010;
octal := 0o755;

// Float literals
float1 := 3.14;
float2 := 1.5e10;
float3 := 2.5e-5;

// ========================================
// 4. STRINGS
// ========================================

// Double-quoted strings
str1 := "Hello, World!";
str2 := "Escaped characters: \n \t \\ \"";

// Single-quoted strings
str3 := 'Single quotes';

// ========================================
// 5. ATOMS (SYMBOLS)
// ========================================

atom1 := :ok;
atom2 := :error;
atom3 := :message_type;
atom4 := :CamelCase;

// ========================================
// 6. OPERATORS
// ========================================

// Arithmetic operators
a := 10 + 5;
b := 20 - 8;
c := 4 * 3;
d := 15 / 3;
e := 17 % 5;

// Comparison operators
cmp1 := 5 == 5;
cmp2 := 5 != 6;
cmp3 := 5 < 10;
cmp4 := 10 > 5;
cmp5 := 5 <= 5;
cmp6 := 10 >= 5;

// Logical operators
log1 := true && false;
log2 := true || false;
log3 := !true;

// Bitwise operators
bit1 := 5 & 3;
bit2 := 5 | 3;
bit3 := 5 << 2;
bit4 := 20 >> 2;
bit5 := ~5;

// Assignment operators
val := 42;
val = 43;

// Special operators
arrow := fn(x) -> x + 1;  // Arrow operator
piped := value |> transform;  // Pipe operator
pinned := ^existing_var;  // Pin operator
spread := [...array];  // Spread operator

// ========================================
// 7. DATA STRUCTURES
// ========================================

// Arrays
empty_array := [];
array := [1, 2, 3, 4, 5];
nested_array := [[1, 2], [3, 4], [5, 6]];
mixed_array := [1, "two", :three, true];

// Tuples
tuple := (1, 2, 3);
pair := (x, y);
singleton := (42);

// Maps
empty_map := %{};
map := %{
    name: "Alice",
    age: 30,
    active: true
};
nested_map := %{
    user: %{
        id: 1,
        name: "Bob"
    }
};

// Tagged tuples (enums)
ok_result := (:Ok, 42);
err_result := (:Err, "Something went wrong");
none := (:None);

// ========================================
// 8. BITSTRINGS AND BINARIES
// ========================================

// Binary literals
bin1 := <<1, 2, 3, 4>>;
bin2 := <<0xFF, 0xAB, 0xCD>>;

// Bitstring patterns
<% header::8, length::16, data::binary %> = binary_data;
<% x::4, y::4 %> = <<0xAB>>;

// ========================================
// 9. FUNCTIONS
// ========================================

// Simple function
add := fn(x, y) {
    return x + y;
};

// Function with guard
positive := fn(x) if x > 0 {
    return x;
};

// Function with pattern matching parameters
process := fn((x, y)) {
    return x + y;
};

// Function with default parameters
greet := fn(name, greeting := "Hello") {
    return greeting + ", " + name;
};

// Function with rest parameters
sum := fn(first, ...rest) {
    total := first;
    for (item in rest) {
        total = total + item;
    };
    return total;
};

// Anonymous function
callback := fn(x) {
    System.print(x);
};

// Higher-order function
map := fn(array, transform) {
    result := [];
    for (item in array) {
        result = Array.push(result, transform(item));
    };
    return result;
};

// ========================================
// 10. CONTROL FLOW
// ========================================

// If-else statement
if (condition) {
    System.print("true branch");
} else {
    System.print("false branch");
};

// While loop
counter := 0;
while (counter < 10) {
    System.print(counter);
    counter = counter + 1;
};

// For loop
for (item in array) {
    System.print(item);
};

// Break and continue
while (true) {
    if (should_skip) {
        continue;
    };
    if (should_stop) {
        break;
    };
};

// ========================================
// 11. PATTERN MATCHING
// ========================================

// Match expression
result := match value {
    | 0 -> "zero";
    | 1 -> "one";
    | n if n > 0 -> "positive";
    | n if n < 0 -> "negative";
    | _ -> "unknown";
};

// Match with enum patterns
response := match http_result {
    | :Ok(data) -> data;
    | :Err(error) -> handle_error(error);
};

// Match with tuple patterns
coords := match point {
    | (0, 0) -> "origin";
    | (x, 0) -> "on x-axis";
    | (0, y) -> "on y-axis";
    | (x, y) -> "somewhere else";
};

// Match with array patterns
list_match := match list {
    | [] -> "empty";
    | [x] -> "singleton";
    | [first, ...rest] -> "multiple elements";
};

// Match with map patterns
user_match := match user {
    | %{role: :admin} -> "admin user";
    | %{role: :guest} -> "guest user";
    | _ -> "regular user";
};

// Destructuring assignment
(x, y, z) := (1, 2, 3);
[first, second, ...rest] := [1, 2, 3, 4, 5];
%{name: user_name, age: user_age} = user;

// Pattern with pin operator
expected := 42;
^expected = value;  // Only matches if value == 42

// Pattern with as
(x, y) as point = coordinates;

// ========================================
// 12. EXCEPTION HANDLING
// ========================================

// Try-catch
result := try {
    risky_operation();
} catch (error) {
    System.print("Error: " + String.from_value(error));
    default_value;
};

// Throw
if (invalid_input) {
    throw "Invalid input provided";
};

// ========================================
// 13. ACTOR SYSTEM
// ========================================

// Actor protocol definition
Counter := %{
    start: fn() {
        count := 0;
        
        while (true) {
            msg := Actor.receive();
            
            if (msg.0 == :increment) {
                count = count + 1;
                System.print("Count: " + String.from_int(count));
            } else if (msg.0 == :decrement) {
                count = count - 1;
            } else if (msg.0 == :get) {
                sender := msg.1;
                Actor.send(sender, (:count, count));
            } else if (msg.0 == :stop) {
                break;
            }
        }
    }
};

// Spawn actor
pid := Actor.spawn(Counter);

// Send messages
Actor.send(pid, (:increment));
Actor.send(pid, (:increment));
Actor.send(pid, (:decrement));

// Get current actor PID
self_pid := Actor.pid();

// Request-reply pattern
Actor.send(pid, (:get, self_pid));
reply := Actor.receive();

// Selective receive
target_msg := Actor.receive_select(fn(m) {
    return m.0 == :target;
});

// Check if actor is alive
if (Actor.is_alive(pid)) {
    Actor.send(pid, (:message));
};

// Terminate actor
Actor.exit(pid, :shutdown);

// ========================================
// 14. PROMISES (ASYNC)
// ========================================

// Create promise
p := Promise.new(fn() {
    // Async work
    return expensive_computation();
});

// Await promise
result := p.await();

// ========================================
// 15. BUILT-IN NAMESPACES AND FUNCTIONS
// ========================================

// System namespace
System.print("Hello, World!");
System.println("With newline");
System.assert(condition);

// String methods
str := String.from_int(42);
upper := String.upper("hello");
lower := String.lower("WORLD");

// Array methods
arr := Array.push(array, item);
length := Array.length(array);
sliced := Array.slice(array, start, end);

// Object methods
obj := Object.new();
cloned := Object.clone(obj);

// Crypto namespace
hash := Crypto.sha256("data");
key := Crypto.strongRandBytes(32);
encrypted := Crypto.aesGcmEncrypt(key, iv, plaintext, aad);

// Random namespace
random_int := Random.int(1, 100);
random_float := Random.float();

// ========================================
// 16. THIS KEYWORD
// ========================================

MyObject := %{
    value: 42,
    
    getValue: fn() {
        return this.value;  // this refers to the object
    },
    
    setValue: fn(new_value) {
        this.value = new_value;
    }
};

result := MyObject.getValue();

// ========================================
// 17. COMPLEX EXAMPLES
// ========================================

// Fibonacci with pattern matching and recursion
fib := fn(n) {
    match n {
        | 0 -> 0;
        | 1 -> 1;
        | n -> fib(n - 1) + fib(n - 2);
    }
};

// Worker pool pattern
Worker := %{
    start: fn() {
        worker_id := this.id;
        
        while (true) {
            msg := Actor.receive();
            
            match msg {
                | (:task, task, sender) -> {
                    result := process_task(task);
                    Actor.send(sender, (:result, result, worker_id));
                };
                | (:stop) -> break;
                | _ -> System.print("Unknown message");
            }
        }
    }
};

// Functional programming style
numbers := [1, 2, 3, 4, 5];
doubled := numbers |> Array.map(fn(x) -> x * 2);
filtered := doubled |> Array.filter(fn(x) -> x > 5);
sum := filtered |> Array.reduce(fn(acc, x) -> acc + x, 0);

// State machine
StateMachine := %{
    start: fn() {
        state := :idle;
        
        while (true) {
            msg := Actor.receive();
            
            (new_state, response) := match (state, msg) {
                | (:idle, (:connect, sender)) -> {
                    (:connected, (:ok, "Connected"));
                };
                | (:connected, (:disconnect, sender)) -> {
                    (:idle, (:ok, "Disconnected"));
                };
                | (:connected, (:send, data, sender)) -> {
                    (:connected, (:ok, "Sent: " + data));
                };
                | (s, (:stop)) -> {
                    break;
                };
                | (s, _) -> {
                    (s, (:error, "Invalid state transition"));
                };
            };
            
            state = new_state;
            Actor.send(msg.1, response);
        }
    }
};

// ========================================
// END OF TEST FILE
// ========================================

System.print("Syntax test complete!");

